#reader(lib"read.ss""wxme")WXME0108 ## 
#|
   This file uses the GRacket editor format.
   Open this file in DrRacket version 6.6 or later to read it.

   Most likely, it was created by saving a program in DrRacket,
   and it probably contains a program with non-text elements
   (such as images or comment boxes).

            http://racket-lang.org/
|#
 32 7 #"wxtext\0"
3 1 6 #"wxtab\0"
1 1 8 #"wximage\0"
2 0 8 #"wxmedia\0"
4 1 34 #"(lib \"syntax-browser.ss\" \"mrlib\")\0"
1 0 36 #"(lib \"cache-image-snip.ss\" \"mrlib\")\0"
1 0 68
(
 #"((lib \"image-core.ss\" \"mrlib\") (lib \"image-core-wxme.rkt\" \"mr"
 #"lib\"))\0"
) 1 0 16 #"drscheme:number\0"
3 0 44 #"(lib \"number-snip.ss\" \"drscheme\" \"private\")\0"
1 0 36 #"(lib \"comment-snip.ss\" \"framework\")\0"
1 0 93
(
 #"((lib \"collapsed-snipclass.ss\" \"framework\") (lib \"collapsed-sni"
 #"pclass-wxme.ss\" \"framework\"))\0"
) 0 0 43 #"(lib \"collapsed-snipclass.ss\" \"framework\")\0"
0 0 19 #"drscheme:sexp-snip\0"
0 0 29 #"drscheme:bindings-snipclass%\0"
1 0 101
(
 #"((lib \"ellipsis-snip.rkt\" \"drracket\" \"private\") (lib \"ellipsi"
 #"s-snip-wxme.rkt\" \"drracket\" \"private\"))\0"
) 2 0 88
(
 #"((lib \"pict-snip.rkt\" \"drracket\" \"private\") (lib \"pict-snip.r"
 #"kt\" \"drracket\" \"private\"))\0"
) 0 0 34 #"(lib \"bullet-snip.rkt\" \"browser\")\0"
0 0 25 #"(lib \"matrix.ss\" \"htdp\")\0"
1 0 22 #"drscheme:lambda-snip%\0"
1 0 29 #"drclickable-string-snipclass\0"
0 0 26 #"drracket:spacer-snipclass\0"
0 0 57
#"(lib \"hrule-snip.rkt\" \"macro-debugger\" \"syntax-browser\")\0"
1 0 26 #"drscheme:pict-value-snip%\0"
0 0 45 #"(lib \"image-snipr.ss\" \"slideshow\" \"private\")\0"
1 0 38 #"(lib \"pict-snipclass.ss\" \"slideshow\")\0"
2 0 55 #"(lib \"vertical-separator-snip.ss\" \"stepper\" \"private\")\0"
1 0 18 #"drscheme:xml-snip\0"
1 0 31 #"(lib \"xml-snipclass.ss\" \"xml\")\0"
1 0 21 #"drscheme:scheme-snip\0"
2 0 34 #"(lib \"scheme-snipclass.ss\" \"xml\")\0"
1 0 10 #"text-box%\0"
1 0 32 #"(lib \"text-snipclass.ss\" \"xml\")\0"
1 0 1 6 #"wxloc\0"
          0 0 61 0 1 #"\0"
0 75 1 #"\0"
0 10 90 -1 90 -1 3 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 255 255 255 1 -1 0 9
#"Standard\0"
0 75 12 #"Courier New\0"
0 10 90 -1 90 -1 3 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 255 255 255 1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0 -1 -1 2 24
#"framework:default-color\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 255 255 255 -1 -1 2
1 #"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 150 0 150 0 0 0 -1 -1 2 15
#"text:ports out\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 150 0 150 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1.0 0 -1 -1 93 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 255 0 0 0 0 0 -1
-1 2 15 #"text:ports err\0"
0 -1 1 #"\0"
1 0 -1 -1 93 -1 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 175 0 0 0 -1 -1 2 17
#"text:ports value\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 175 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 34 139 34 0 0 0 -1
-1 2 27 #"Matching Parenthesis Style\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 34 139 34 0 0 0 -1
-1 2 1 #"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 37
#"framework:syntax-color:scheme:symbol\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 38
#"framework:syntax-color:scheme:keyword\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 194 116 31 0 0 0 -1 -1 2
38 #"framework:syntax-color:scheme:comment\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 194 116 31 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 37
#"framework:syntax-color:scheme:string\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 35
#"framework:syntax-color:scheme:text\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 39
#"framework:syntax-color:scheme:constant\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 49
#"framework:syntax-color:scheme:hash-colon-keyword\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 42
#"framework:syntax-color:scheme:parenthesis\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 36
#"framework:syntax-color:scheme:error\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 36
#"framework:syntax-color:scheme:other\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 16
#"Misspelled Text\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 81 112 203 0 0 0 -1 -1 2
38 #"drracket:check-syntax:lexically-bound\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 81 112 203 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 28
#"drracket:check-syntax:set!d\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 37
#"drracket:check-syntax:unused-require\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 36
#"drracket:check-syntax:free-variable\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 68 0 203 0 0 0 -1 -1 2 31
#"drracket:check-syntax:imported\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 68 0 203 0 0 0 -1 -1 2 47
#"drracket:check-syntax:my-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 116 0 0 0 0 -1 -1 2 50
#"drracket:check-syntax:their-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 116 0 0 0 0 -1 -1 2 48
#"drracket:check-syntax:unk-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 139 142 28 0 0 0 -1 -1 2
49 #"drracket:check-syntax:both-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 139 142 28 0 0 0 -1 -1 2
26 #"plt:htdp:test-coverage-on\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 2 27
#"plt:htdp:test-coverage-off\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 4 1
#"\0"
0 70 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 4 4 #"XML\0"
0 70 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 2 37 #"plt:module-language:test-coverage-on\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 38
#"plt:module-language:test-coverage-off\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 4 1
#"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 4 1 #"\0"
0 -1 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 1 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 0 255 0 0 0 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 1 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 0 255 0 0 0 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 100 0 0 0 0 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 93 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 255 0 0 0 0 0 -1
-1 2 1 #"\0"
0 70 1 #"\0"
1.0 0 -1 -1 93 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 148 0 211 0 0 0 -1
-1 2 1 #"\0"
0 70 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 1 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 0 255 0 0 0 -1
-1 0 1 #"\0"
0 -1 1 #"\0"
0 12 -1 -1 -1 -1 -1 -1 0 0 1 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 2 1 #"\0"
0 -1 1 #"\0"
0 12 -1 -1 -1 -1 -1 -1 0 0 1 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 4 1 #"\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 255 255 0 -1 -1
          0 778 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 29 #"CS 270 Math Foundations of CS"
0 0 17 29 1 #"\n"
0 0 17 3 12 #"Fall 2016-17"
0 0 17 29 1 #"\n"
0 0 17 3 49 #"Instructor:  Profs. Jeremy Johnson and Mark Boady"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 12 #"Assignment 1"
0 0 17 29 1 #"\n"
0 0 17 3 44 #"Introduction to Racket and boolean functions"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 71
(
 #"In the first part of the assignment students will implement the bool"
 #"ean"
) 0 0 17 29 1 #"\n"
0 0 17 3 59
#"functions not, and, or xor, implies, and iff using Racket's"
0 0 17 29 1 #"\n"
0 0 17 3 57 #"if expression.  Note that Racket already implements these"
0 0 17 29 1 #"\n"
0 0 17 3 7 #"Boolean"
0 0 17 3 52 #" functions using the names above.  Therefore we will"
0 0 17 29 1 #"\n"
0 0 17 3 65
#"name our implementations noti, andi, ori, xori, impliesi and iffi"
0 0 17 29 1 #"\n"
0 0 17 3 62
#"so as not to cause confusion.  Your implementation may not use"
0 0 17 29 1 #"\n"
0 0 17 3 63
#"the builtin Boolean functions and must only use if expressions."
0 0 17 29 1 #"\n"
0 0 17 3 65
#"This exercise shows that all Boolean functions can be implemented"
0 0 17 29 1 #"\n"
0 0 17 3 41 #"using if and hence they need not be primi"
0 0 17 3 5 #"tive."
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 68
#"The functions noti, andi, ori, xori, impliesi and iffi are specified"
0 0 17 29 1 #"\n"
0 0 17 3 63
#"informally in the specification comments and are also specified"
0 0 17 29 1 #"\n"
0 0 17 3 67
#"using unit tests.  For each function you need to put in the missing"
0 0 17 29 1 #"\n"
0 0 17 3 68
#"code and make sure it passes the corresponding unit tests.  Function"
0 0 17 29 1 #"\n"
0 0 17 3 66
#"definitions and the corresponding unit tests are commented out. As"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"you imple"
0 0 17 3 57 #"ment each function, uncomment the definition, fill in the"
0 0 17 29 1 #"\n"
0 0 17 3 65
#"implementation, and uncomment the corresponding unit test to test"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"your implementation."
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 66
#"After you have implemented noti, andi, xori, impliesi and iffi and"
0 0 17 29 1 #"\n"
0 0 17 3 68
#"the have passed all of their associated unit tests, you are to write"
0 0 17 29 1 #"\n"
0 0 17 3 54 #"unit tests to verify the following Boolean identities:"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"1)  (impliesi p"
0 0 17 3 54 #" q) = (ori (noti p) q) for all possible Boolean values"
0 0 17 29 1 #"\n"
0 0 17 3 26 #"for the variables p and q."
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 69
(
 #"2) (iffi p q) = (andi (impliesi p q) (impliesi q p)) for all possibl"
 #"e"
) 0 0 17 29 1 #"\n"
0 0 17 3 41 #"boolean values for the variables p and q."
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 72
(
 #"In the second part of the assignment, students students are to imple"
 #"ment"
) 0 0 17 29 1 #"\n"
0 0 17 3 67
#"several Boolean functions which take an arbitrary number of inputs."
0 0 17 29 1 #"\n"
0 0 17 3 16 #"First you are to"
0 0 17 3 48 #" use foldr to implement and applied to a list of"
0 0 17 29 1 #"\n"
0 0 17 3 67
#"Boolean values and or applied to a list or Boolean values. Then you"
0 0 17 29 1 #"\n"
0 0 17 3 70
(
 #"are to implement, using recursion, several functions that input a li"
 #"st"
) 0 0 17 29 1 #"\n"
0 0 17 3 73
(
 #"of integers and check for all ones, atleast one one, exactly one one"
 #", and"
) 0 0 17 29 1 #"\n"
0 0 17 3 22 #"an odd number of ones."
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 67
#"There are a total of 13 questions.  All but two of the questions (7"
0 0 17 3 7 #" and 8)"
0 0 17 29 1 #"\n"
0 0 17 3 67
#"ask you to implement the specified function and to test it with the"
0 0 17 29 1 #"\n"
0 0 17 3 73
(
 #"provided unit tests, which serve as further specification.  The ques"
 #"tions"
) 0 0 17 29 1 #"\n"
0 0 17 3 62
#"that do not ask for a function definition ask you to provide a"
0 0 17 29 1 #"\n"
0 0 17 3 66
#"unit test that verifies a specified property of Boolean functions."
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 28 3 12 #"#lang racket"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 7 #"require"
0 0 24 3 1 #" "
0 0 14 3 8 #"rackunit"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 7 #"require"
0 0 24 3 1 #" "
0 0 14 3 16 #"rackunit/text-ui"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";Question 1.  Fill in the ... in the definition of noti to implement"
0 0 24 29 1 #"\n"
0 0 17 3 65
#";logical negation.  Uncomment the corresponding unit test to test"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";your implementation."
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 18 #"; logical negation"
0 0 17 29 1 #"\n"
0 0 17 3 22 #"; input:  (boolean? e)"
0 0 17 29 1 #"\n"
0 0 17 3 69
(
 #"; output:  (boolean? (noti e)) true e is false and false if e is tru"
 #"e"
) 0 0 17 29 1 #"\n"
0 0 17 3 16 #"(define (noti e)"
0 0 17 29 1 #"\n"
0 0 17 3 7 #"  ... )"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 27 #"(define-test-suite testnoti"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 17 #"    (noti #f) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 17 #"    (noti #t) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 1 #")"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 35 #"(print \"Question 1:  Testing noti\")"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"(newline)"
0 0 17 29 1 #"\n"
0 0 17 3 29 #"(run-tests testnoti 'verbose)"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";Question 2.  Fill in the ... in the definition of andi to implement"
0 0 24 29 1 #"\n"
0 0 17 3 60
#";logical and.  Uncomment the corresponding unit test to test"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";your implementation."
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 13 #"; logical and"
0 0 17 29 1 #"\n"
0 0 17 3 43 #"; input:  e1 and e2 are boolean expressions"
0 0 17 29 1 #"\n"
0 0 17 3 19 #"; output:  (boolean"
0 0 17 3 47 #"? (andi e1 e2)) true if both e1 and e2 are true"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"(define (andi e1 e2)"
0 0 17 29 1 #"\n"
0 0 17 3 7 #"  ... )"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 27 #"(define-test-suite testandi"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"    (andi #f #f) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"    (andi #f #t) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"    (andi #t #f) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"    (andi #t #t) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 1 #")"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 35 #"(print \"Question 2:  Testing andi\")"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"(newline)"
0 0 17 29 1 #"\n"
0 0 17 3 29 #"(run-tests testandi 'verbose)"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 67
#";Question 3.  Fill in the ... in the definition of ori to implement"
0 0 24 29 1 #"\n"
0 0 17 3 59
#";logical or.  Uncomment the corresponding unit test to test"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";your implementation."
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 12 #"; logical or"
0 0 24 29 1 #"\n"
0 0 17 3 43 #"; input:  e1 and e2 are boolean expressions"
0 0 24 29 1 #"\n"
0 0 17 3 66
#"; output:  (boolean? (ori e1 e2)) true if either e1 or e2 are true"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 19 #"(define (ori e1 e2)"
0 0 17 29 1 #"\n"
0 0 17 3 7 #"  ... )"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 26 #"(define-test-suite testori"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 19 #"    (ori #f #f) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 19 #"    (ori #f #t) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 19 #"    (ori #t #f) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 19 #"    (ori #t #t) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 1 #")"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 34 #"(print \"Question 3:  Testing ori\")"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"(newline)"
0 0 17 29 1 #"\n"
0 0 17 3 28 #"(run-tests testori 'verbose)"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";Question 4.  Fill in the ... in the definition of xori to implement"
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";logical exclusive or.  Uncomment the corresponding unit test to tes"
 #"t"
) 0 0 24 29 1 #"\n"
0 0 17 3 21 #";your implementation."
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 1 #"#"
0 0 17 3 1 #"|"
0 0 17 29 1 #"\n"
0 0 17 3 13 #"; logical xor"
0 0 17 29 1 #"\n"
0 0 17 3 43 #"; input:  e1 and e2 are boolean expressions"
0 0 17 29 1 #"\n"
0 0 17 3 66
#"; output:  (boolean? (xori e1 e2)) true if exactly one of e1 or e2"
0 0 17 29 1 #"\n"
0 0 17 3 19 #";          are true"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"(define (xori e1 e2)"
0 0 17 29 1 #"\n"
0 0 17 3 7 #"  ... )"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 27 #"(define-test-suite testxori"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"    (xori #f #f) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"    (xori #f #t) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"    (xori #t #f) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"    (xori #t #t) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 1 #")"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 35 #"(print \"Question 4:  Testing xori\")"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"(newline)"
0 0 17 29 1 #"\n"
0 0 17 3 29 #"(run-tests testxori 'verbose)"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";Question 5.  Fill in the ... in the definition of impliesi to imple"
 #"ment"
) 0 0 24 29 1 #"\n"
0 0 17 3 68
#";logical implication.  Uncomment the corresponding unit test to test"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";your implementation."
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 21 #"; logical implication"
0 0 17 29 1 #"\n"
0 0 17 3 43 #"; input:  e1 and e2 are boolean expressions"
0 0 17 29 1 #"\n"
0 0 17 3 35 #"; output:  (boolean? (impliesi e1 e"
0 0 17 3 26 #"2)) true if e1 is false or"
0 0 17 29 1 #"\n"
0 0 17 3 27 #"; e1 is true and e2 is true"
0 0 17 29 1 #"\n"
0 0 17 3 24 #"(define (impliesi e1 e2)"
0 0 17 29 1 #"\n"
0 0 17 3 7 #"  ... )"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 31 #"(define-test-suite testimpliesi"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 24 #"    (impliesi #f #f) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 24 #"    (impliesi #f #t) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 24 #"    (impliesi #t #f) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 24 #"    (impliesi #t #t) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 1 #")"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 39 #"(print \"Question 5:  Testing impliesi\")"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"(newline)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"(run-tests test"
0 0 17 3 18 #"impliesi 'verbose)"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";Question 6.  Fill in the ... in the definition of iffi to implement"
0 0 24 29 1 #"\n"
0 0 17 3 67
#";logical equivalence (if and only if).  Uncomment the corresponding"
0 0 24 29 1 #"\n"
0 0 17 3 39 #";unit test to test your implementation."
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 14 #"; logical iffi"
0 0 17 29 1 #"\n"
0 0 17 3 43 #"; input:  e1 and e2 are boolean expressions"
0 0 17 29 1 #"\n"
0 0 17 3 69
(
 #"; output:  (boolean? (iffi e1 e2)) true if e1 and e2 are both true o"
 #"f"
) 0 0 17 29 1 #"\n"
0 0 17 3 21 #";           both fals"
0 0 17 3 1 #"e"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"(define (iffi e1 e2)"
0 0 17 29 1 #"\n"
0 0 17 3 7 #"  ... )"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 27 #"(define-test-suite testiffi"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"    (iffi #f #f) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"    (iffi #f #t) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"    (iffi #t #f) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"    (iffi #t #t) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 1 #")"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 35 #"(print \"Question 6:  Testing iffi\")"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"(newline)"
0 0 17 29 1 #"\n"
0 0 17 3 29 #"(run-tests testiffi 'verbose)"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 65
#"; Question 7.  Define a unit test to test the Boolean equivalence"
0 0 24 29 1 #"\n"
0 0 17 3 59
#"; (iffi e1 e2) <-> (andi (impliesi e1 e2) (impliesi e2 e1))"
0 0 24 29 1 #"\n"
0 0 17 3 44 #"; Note that the symbol <-> means equivalent."
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #"; You should create test cases for all possible values (#f and #t) o"
 #"f"
) 0 0 24 29 1 #"\n"
0 0 17 3 67
#"; the Boolean variables e1 and e2 and test the that two expressions"
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #"; (iffi e1 e2) and (andi (impliesi e1 e2) (impliesi e2 e1)) are equa"
 #"l"
) 0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #"; for all possible values of e1 and e2. Replace ... by your test cas"
 #"es."
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 59
#"; (iffi e1 e2) <-> (andi (impliesi e1 e2) (impliesi e2 e1))"
0 0 17 29 1 #"\n"
0 0 17 3 31 #"(define-test-suite testiffequiv"
0 0 17 29 1 #"\n"
0 0 17 3 5 #"  ..."
0 0 17 29 1 #"\n"
0 0 17 3 1 #")"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 46 #"(print \"Question 7:  Testing iff equivalence\")"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"(newline)"
0 0 17 29 1 #"\n"
0 0 17 3 33 #"(run-tests testiffequiv 'verbose)"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 65
#"; Question 8.  Define a unit test to test the Boolean equivalence"
0 0 24 29 1 #"\n"
0 0 17 3 41 #"; (impliesi e1 e2) <-> (ori (noti e1) e2)"
0 0 24 29 1 #"\n"
0 0 17 3 44 #"; Note that the symbol <-> means equivalent."
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #"; You should create test cases for all possible values (#f and #t) o"
 #"f"
) 0 0 24 29 1 #"\n"
0 0 17 3 67
#"; the Boolean variables e1 and e2 and test the that two expressions"
0 0 24 29 1 #"\n"
0 0 17 3 55 #"; (impliesi e1 e2) and (ori (noti e1) e2) are equal for"
0 0 24 29 1 #"\n"
0 0 17 3 68
#"; all possible values of e1 and e2.  Replace ... by your test cases."
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 40 #"; (implies e1 e2) <-> (ori (noti e1) e2)"
0 0 17 29 1 #"\n"
0 0 17 3 8 #"(define-"
0 0 17 3 27 #"test-suite testimpliesequiv"
0 0 17 29 1 #"\n"
0 0 17 3 3 #"..."
0 0 17 29 1 #"\n"
0 0 17 3 1 #")"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 50 #"(print \"Question 8:  Testing implies equivalence\")"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"(newline)"
0 0 17 29 1 #"\n"
0 0 17 3 37 #"(run-tests testimpliesequiv 'verbose)"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";Question 9."
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #"; Use foldr to implement (andlist L) where (andlist L) is the Boolea"
 #"n"
) 0 0 24 29 1 #"\n"
0 0 17 3 66
#"; and of a list of Boolean values L.  Note that (and L1 ... Ln) is"
0 0 24 29 1 #"\n"
0 0 17 3 67
#"; defined as (and L1 (and L2 ... (and L_{n-1} Ln) ... ) and is true"
0 0 24 29 1 #"\n"
0 0 17 3 30 #"; when all of the Li are true."
0 0 24 29 1 #"\n"
0 0 17 3 1 #";"
0 0 24 29 1 #"\n"
0 0 17 3 67
#"; Use foldr to implement (orlist L) where (orlist L) is the Boolean"
0 0 24 29 1 #"\n"
0 0 17 3 64
#"; or of a list of Boolean values L.  Note that (or L1 ... Ln) is"
0 0 24 29 1 #"\n"
0 0 17 3 64
#"; defined as (or L1 (or L2 ... (or L_{n-1} Ln) ... ) and is true"
0 0 24 29 1 #"\n"
0 0 17 3 42 #"; when all atleast one of the Li are true."
0 0 24 29 1 #"\n"
0 0 17 3 68
#"; In both cases, fill in the ... with the proper arguments to foldr."
0 0 24 29 1 #"\n"
0 0 17 3 59
#"; Use the unit test provided to check your implementations."
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 19 #"(define (andlist L)"
0 0 17 29 1 #"\n"
0 0 17 3 14 #"  (foldr ... )"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 18 #"(define (orlist L)"
0 0 17 29 1 #"\n"
0 0 17 3 14 #"  (foldr ... )"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 31 #"(define-test-suite testboollist"
0 0 17 29 1 #"\n"
0 0 17 3 33 #"  (check-equal? (andlist '()) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 32 #"  (check-equal? (orlist '()) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 41 #"  (check-equal? (andlist '(#t #t #t)) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 41 #"  (check-equal? (andlist '(#t #f #t)) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 40 #"  (check-equal? (orlist '(#f #t #f)) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 40 #"  (check-equal? (orlist '(#f #f #f)) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 1 #")"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 49 #"(print \"Question 9:  Testing orlist and andlist\")"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"(newline)"
0 0 17 29 1 #"\n"
0 0 17 3 33 #"(run-tests testboollist 'verbose)"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";Question 10."
0 0 24 29 1 #"\n"
0 0 17 3 67
#"; Write a recursive function allones to check if a list of integers"
0 0 24 29 1 #"\n"
0 0 17 3 61
#"; contains all ones.  Use the provided unit test to test your"
0 0 24 29 1 #"\n"
0 0 17 3 67
#"; implementation.  Fill in the ... with your implementation.  Don't"
0 0 24 29 1 #"\n"
0 0 17 3 52 #"; forget the base case and the necessary recursion. "
0 0 24 29 1 #"\n"
0 0 17 3 2 #"; "
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 35 #"; Check if a list contains all ones"
0 0 17 29 1 #"\n"
0 0 17 3 34 #"; Input:  L is a list of integers."
0 0 17 29 1 #"\n"
0 0 17 3 69
(
 #"; Output: a boolean value which is true when all of the elements in "
 #"L"
) 0 0 17 29 1 #"\n"
0 0 17 3 47 #";         are equal to one and false otherwise."
0 0 17 29 1 #"\n"
0 0 17 3 19 #"(define (allones L)"
0 0 17 29 1 #"\n"
0 0 17 3 7 #"  ... )"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 30 #"(define-test-suite testallones"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 26 #"    (allones '(1 0 1)) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 1 #" "
0 0 17 3 14 #" (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 26 #"    (allones '(1 1 1)) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 1 #")"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 39 #"(print \"Question 10:  Testing allones\")"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"(newline)"
0 0 17 29 1 #"\n"
0 0 17 3 32 #"(run-tests testallones 'verbose)"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";Question 11."
0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #"; Write a recursive function atleastone to check if a list of intege"
 #"rs"
) 0 0 24 29 1 #"\n"
0 0 17 3 67
#"; contains atleast one one. Use the provided unit test to test your"
0 0 24 29 1 #"\n"
0 0 17 3 75
(
 #"; implementation.  Don't forget the base case and the necessary recu"
 #"rsion. "
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 42 #"; Check if a list contains atleast one one"
0 0 17 29 1 #"\n"
0 0 17 3 34 #"; Input:  L is a list of integers."
0 0 17 29 1 #"\n"
0 0 17 3 72
(
 #"; Output: a boolean value which is true when atleast one of the elem"
 #"ents"
) 0 0 17 29 1 #"\n"
0 0 17 3 52 #";          in L is equal to one and false otherwise."
0 0 17 29 1 #"\n"
0 0 17 3 22 #"(define (atleastone L)"
0 0 17 29 1 #"\n"
0 0 17 3 7 #"  ... )"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 33 #"(define-test-suite testatleastone"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 29 #"    (atleastone '(0 0 0)) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"    (atle"
0 0 17 3 20 #"astone '(0 0 1)) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 29 #"    (atleastone '(1 0 1)) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 29 #"    (atleastone '(1 1 1)) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 1 #")"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 42 #"(print \"Question 11:  Testing atleastone\")"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"(newline)"
0 0 17 29 1 #"\n"
0 0 17 3 35 #"(run-tests testatleastone 'verbose)"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";Question 12."
0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #"; Write a recursive function exactlyone to check if a list of intege"
 #"rs"
) 0 0 24 29 1 #"\n"
0 0 17 3 67
#"; contains exactly one one. Use the provided unit test to test your"
0 0 24 29 1 #"\n"
0 0 17 3 75
(
 #"; implementation.  Don't forget the base case and the necessary recu"
 #"rsion. "
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 42 #"; Check if a list contains exactly one one"
0 0 17 29 1 #"\n"
0 0 17 3 34 #"; Input:  L is a list of integers."
0 0 17 29 1 #"\n"
0 0 17 3 72
(
 #"; Output: a boolean value which is true when exactly one of the elem"
 #"ents"
) 0 0 17 29 1 #"\n"
0 0 17 3 53 #";          in L is equal to one and false otherwise. "
0 0 17 29 1 #"\n"
0 0 17 3 22 #"(define (exactlyone L)"
0 0 17 29 1 #"\n"
0 0 17 3 7 #"  ... )"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 28 #"(define-test-suite testexact"
0 0 17 3 6 #"lytone"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 29 #"    (exactlyone '(0 0 0)) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 29 #"    (exactlyone '(0 0 1)) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 29 #"    (exactlyone '(1 0 1)) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 29 #"    (exactlyone '(1 1 1)) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 1 #")"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 43 #"(print \"Question 12:  Testing exactlyones\")"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"(newline)"
0 0 17 29 1 #"\n"
0 0 17 3 36 #"(run-tests testexactlytone 'verbose)"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";Question 13."
0 0 24 29 1 #"\n"
0 0 17 3 67
#"; Write a recursive function oddones to check if a list of integers"
0 0 24 29 1 #"\n"
0 0 17 3 68
#"; contains an odd number of ones. Use the provided unit test to test"
0 0 24 29 1 #"\n"
0 0 17 3 68
#"; your implementation.  Don't forget the base case and the necessary"
0 0 24 29 1 #"\n"
0 0 17 3 13 #"; recursion. "
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 48 #"; Check if a list contains an odd number of ones"
0 0 17 29 1 #"\n"
0 0 17 3 34 #"; Input:  L is a list of integers."
0 0 17 29 1 #"\n"
0 0 17 3 74
(
 #"; Output: a boolean value which is true when an odd number of the el"
 #"ements"
) 0 0 17 29 1 #"\n"
0 0 17 3 20 #";          in L is e"
0 0 17 3 33 #"qual to one and false otherwise. "
0 0 17 29 1 #"\n"
0 0 17 3 19 #"(define (oddones L)"
0 0 17 29 1 #"\n"
0 0 17 3 7 #"  ... )"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 30 #"(define-test-suite testoddones"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 26 #"    (oddones '(0 0 0)) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 26 #"    (oddones '(0 0 1)) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 26 #"    (oddones '(1 0 1)) #f)"
0 0 17 29 1 #"\n"
0 0 17 3 15 #"  (check-equal?"
0 0 17 29 1 #"\n"
0 0 17 3 26 #"    (oddones '(1 1 1)) #t)"
0 0 17 29 1 #"\n"
0 0 17 3 1 #")"
0 0 17 29 1 #"\n"
0 0 17 29 1 #"\n"
0 0 17 3 39 #"(print \"Question 13:  Testing oddones\")"
0 0 17 29 1 #"\n"
0 0 17 3 9 #"(newline)"
0 0 17 29 1 #"\n"
0 0 17 3 32 #"(run-tests testoddones 'verbose)"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0           0
